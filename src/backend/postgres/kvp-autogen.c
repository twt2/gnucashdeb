
/* DO NOT EDIT THIS FILE -- it is autogenerated -- edit table.m4 instead */





/* ------------------------------------------------------ */
/* This routine stores/updates one record in the database.
 * It does not do any traversals, it does not lock.  
 * It just pokes the data in.
 */
void 
pgendStoreOneKVPint64Only (PGBackend *be,
                                    store_data_t *ptr,
                                    sqlBuild_QType update)
{
   const char *buf;
   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_int64", update);
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Int64 (be->builder, "data", ptr->u.ival);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);


   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, );

   /* flush the buffers, check the status */
   FINISH_QUERY(be->connection);
   LEAVE (" ");
}



/* ------------------------------------------------------ */
/* This routine stores/updates one record in the database.
 * It does not do any traversals, it does not lock.  
 * It just pokes the data in.
 */
void 
pgendStoreOneKVPdoubleOnly (PGBackend *be,
                                    store_data_t *ptr,
                                    sqlBuild_QType update)
{
   const char *buf;
   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_dbl", update);
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Double (be->builder, "data", ptr->u.dbl);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);


   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, );

   /* flush the buffers, check the status */
   FINISH_QUERY(be->connection);
   LEAVE (" ");
}



/* ------------------------------------------------------ */
/* This routine stores/updates one record in the database.
 * It does not do any traversals, it does not lock.  
 * It just pokes the data in.
 */
void 
pgendStoreOneKVPnumericOnly (PGBackend *be,
                                    store_data_t *ptr,
                                    sqlBuild_QType update)
{
   const char *buf;
   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_numeric", update);
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Int64 (be->builder, "num", ptr->u.numeric.num);
   sqlBuild_Set_Int64 (be->builder, "denom", ptr->u.numeric.denom);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);


   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, );

   /* flush the buffers, check the status */
   FINISH_QUERY(be->connection);
   LEAVE (" ");
}



/* ------------------------------------------------------ */
/* This routine stores/updates one record in the database.
 * It does not do any traversals, it does not lock.  
 * It just pokes the data in.
 */
void 
pgendStoreOneKVPstringOnly (PGBackend *be,
                                    store_data_t *ptr,
                                    sqlBuild_QType update)
{
   const char *buf;
   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_str", update);
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Str (be->builder, "data", ptr->u.str);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);


   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, );

   /* flush the buffers, check the status */
   FINISH_QUERY(be->connection);
   LEAVE (" ");
}



/* ------------------------------------------------------ */
/* This routine stores/updates one record in the database.
 * It does not do any traversals, it does not lock.  
 * It just pokes the data in.
 */
void 
pgendStoreOneKVPguidOnly (PGBackend *be,
                                    store_data_t *ptr,
                                    sqlBuild_QType update)
{
   const char *buf;
   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_guid", update);
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Str (be->builder, "data", ptr->u.str);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);


   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, );

   /* flush the buffers, check the status */
   FINISH_QUERY(be->connection);
   LEAVE (" ");
}



/* ------------------------------------------------------ */
/* This routine stores/updates one record in the database.
 * It does not do any traversals, it does not lock.  
 * It just pokes the data in.
 */
void 
pgendStoreOneKVPtimespecOnly (PGBackend *be,
                                    store_data_t *ptr,
                                    sqlBuild_QType update)
{
   const char *buf;
   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_timespec", update);
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Date (be->builder, "data", ptr->u.ts);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);


   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, );

   /* flush the buffers, check the status */
   FINISH_QUERY(be->connection);
   LEAVE (" ");
}




/* ------------------------------------------------------ */
/* This routine stores one autdit record in the database.
 * It does not do any traversals, it does not lock.  
 * It just pokes the data in. 
 */
void 
pgendStoreAuditKVPint64 (PGBackend *be,
                                  store_data_t *ptr,
                                  sqlBuild_QType update)
{
   const char *buf;
   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_int64" "Trail", SQL_INSERT);
#define sqlBuild_Where_Str sqlBuild_Set_Str
#define sqlBuild_Where_GUID sqlBuild_Set_GUID
#define sqlBuild_Where_Int32 sqlBuild_Set_Int32
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Int64 (be->builder, "data", ptr->u.ival);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);

#undef sqlBuild_Where_Str
#undef sqlBuild_Where_GUID
#undef sqlBuild_Where_Int32
   sqlBuild_Set_Str (be->builder, "date_changed", "NOW");
   /* sqlBuild_Set_GUID (be->builder, "sessionGUID", be->sessionGuid); */
   sqlBuild_Set_Str (be->builder, "sessionGUID", be->session_guid_str);
   sqlBuild_Set_Char (be->builder, "change", update);
   sqlBuild_Set_Char (be->builder, "objtype", 'k');

   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, );

   /* flush the buffers, check the status */
   FINISH_QUERY(be->connection);
   LEAVE (" ");
}



/* ------------------------------------------------------ */
/* This routine stores one autdit record in the database.
 * It does not do any traversals, it does not lock.  
 * It just pokes the data in. 
 */
void 
pgendStoreAuditKVPdouble (PGBackend *be,
                                  store_data_t *ptr,
                                  sqlBuild_QType update)
{
   const char *buf;
   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_dbl" "Trail", SQL_INSERT);
#define sqlBuild_Where_Str sqlBuild_Set_Str
#define sqlBuild_Where_GUID sqlBuild_Set_GUID
#define sqlBuild_Where_Int32 sqlBuild_Set_Int32
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Double (be->builder, "data", ptr->u.dbl);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);

#undef sqlBuild_Where_Str
#undef sqlBuild_Where_GUID
#undef sqlBuild_Where_Int32
   sqlBuild_Set_Str (be->builder, "date_changed", "NOW");
   /* sqlBuild_Set_GUID (be->builder, "sessionGUID", be->sessionGuid); */
   sqlBuild_Set_Str (be->builder, "sessionGUID", be->session_guid_str);
   sqlBuild_Set_Char (be->builder, "change", update);
   sqlBuild_Set_Char (be->builder, "objtype", 'k');

   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, );

   /* flush the buffers, check the status */
   FINISH_QUERY(be->connection);
   LEAVE (" ");
}



/* ------------------------------------------------------ */
/* This routine stores one autdit record in the database.
 * It does not do any traversals, it does not lock.  
 * It just pokes the data in. 
 */
void 
pgendStoreAuditKVPnumeric (PGBackend *be,
                                  store_data_t *ptr,
                                  sqlBuild_QType update)
{
   const char *buf;
   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_numeric" "Trail", SQL_INSERT);
#define sqlBuild_Where_Str sqlBuild_Set_Str
#define sqlBuild_Where_GUID sqlBuild_Set_GUID
#define sqlBuild_Where_Int32 sqlBuild_Set_Int32
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Int64 (be->builder, "num", ptr->u.numeric.num);
   sqlBuild_Set_Int64 (be->builder, "denom", ptr->u.numeric.denom);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);

#undef sqlBuild_Where_Str
#undef sqlBuild_Where_GUID
#undef sqlBuild_Where_Int32
   sqlBuild_Set_Str (be->builder, "date_changed", "NOW");
   /* sqlBuild_Set_GUID (be->builder, "sessionGUID", be->sessionGuid); */
   sqlBuild_Set_Str (be->builder, "sessionGUID", be->session_guid_str);
   sqlBuild_Set_Char (be->builder, "change", update);
   sqlBuild_Set_Char (be->builder, "objtype", 'k');

   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, );

   /* flush the buffers, check the status */
   FINISH_QUERY(be->connection);
   LEAVE (" ");
}



/* ------------------------------------------------------ */
/* This routine stores one autdit record in the database.
 * It does not do any traversals, it does not lock.  
 * It just pokes the data in. 
 */
void 
pgendStoreAuditKVPstring (PGBackend *be,
                                  store_data_t *ptr,
                                  sqlBuild_QType update)
{
   const char *buf;
   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_str" "Trail", SQL_INSERT);
#define sqlBuild_Where_Str sqlBuild_Set_Str
#define sqlBuild_Where_GUID sqlBuild_Set_GUID
#define sqlBuild_Where_Int32 sqlBuild_Set_Int32
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Str (be->builder, "data", ptr->u.str);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);

#undef sqlBuild_Where_Str
#undef sqlBuild_Where_GUID
#undef sqlBuild_Where_Int32
   sqlBuild_Set_Str (be->builder, "date_changed", "NOW");
   /* sqlBuild_Set_GUID (be->builder, "sessionGUID", be->sessionGuid); */
   sqlBuild_Set_Str (be->builder, "sessionGUID", be->session_guid_str);
   sqlBuild_Set_Char (be->builder, "change", update);
   sqlBuild_Set_Char (be->builder, "objtype", 'k');

   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, );

   /* flush the buffers, check the status */
   FINISH_QUERY(be->connection);
   LEAVE (" ");
}



/* ------------------------------------------------------ */
/* This routine stores one autdit record in the database.
 * It does not do any traversals, it does not lock.  
 * It just pokes the data in. 
 */
void 
pgendStoreAuditKVPguid (PGBackend *be,
                                  store_data_t *ptr,
                                  sqlBuild_QType update)
{
   const char *buf;
   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_guid" "Trail", SQL_INSERT);
#define sqlBuild_Where_Str sqlBuild_Set_Str
#define sqlBuild_Where_GUID sqlBuild_Set_GUID
#define sqlBuild_Where_Int32 sqlBuild_Set_Int32
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Str (be->builder, "data", ptr->u.str);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);

#undef sqlBuild_Where_Str
#undef sqlBuild_Where_GUID
#undef sqlBuild_Where_Int32
   sqlBuild_Set_Str (be->builder, "date_changed", "NOW");
   /* sqlBuild_Set_GUID (be->builder, "sessionGUID", be->sessionGuid); */
   sqlBuild_Set_Str (be->builder, "sessionGUID", be->session_guid_str);
   sqlBuild_Set_Char (be->builder, "change", update);
   sqlBuild_Set_Char (be->builder, "objtype", 'k');

   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, );

   /* flush the buffers, check the status */
   FINISH_QUERY(be->connection);
   LEAVE (" ");
}



/* ------------------------------------------------------ */
/* This routine stores one autdit record in the database.
 * It does not do any traversals, it does not lock.  
 * It just pokes the data in. 
 */
void 
pgendStoreAuditKVPtimespec (PGBackend *be,
                                  store_data_t *ptr,
                                  sqlBuild_QType update)
{
   const char *buf;
   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_timespec" "Trail", SQL_INSERT);
#define sqlBuild_Where_Str sqlBuild_Set_Str
#define sqlBuild_Where_GUID sqlBuild_Set_GUID
#define sqlBuild_Where_Int32 sqlBuild_Set_Int32
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Date (be->builder, "data", ptr->u.ts);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);

#undef sqlBuild_Where_Str
#undef sqlBuild_Where_GUID
#undef sqlBuild_Where_Int32
   sqlBuild_Set_Str (be->builder, "date_changed", "NOW");
   /* sqlBuild_Set_GUID (be->builder, "sessionGUID", be->sessionGuid); */
   sqlBuild_Set_Str (be->builder, "sessionGUID", be->session_guid_str);
   sqlBuild_Set_Char (be->builder, "change", update);
   sqlBuild_Set_Char (be->builder, "objtype", 'k');

   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, );

   /* flush the buffers, check the status */
   FINISH_QUERY(be->connection);
   LEAVE (" ");
}




/* ------------------------------------------------------ */
/* This routine returns a positive int if the indicated object
 * differs from that in the SQL database.  It returns negative
 * number if theres an error.
 * It does not do any traversals, it does not lock.  
 */
int
pgendCompareOneKVPint64Only (PGBackend *be, store_data_t *ptr)
{
   const char *buf;
   PGresult *result;
   int i=0, nrows=0, ndiffs=0;

   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return -1;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_int64", SQL_SELECT);
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Int64 (be->builder, "data", ptr->u.ival);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);


   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, -1);

   i=0; nrows=0;
   do {
      GET_RESULTS (be->connection, result);
      IF_ONE_ROW (result, nrows, i) {

         /* Compare queried values to input values. */
             COMP_STR ("type", ptr->stype, ndiffs);
    COMP_INT64 ("data", ptr->u.ival, ndiffs);

      }

      PQclear (result);
      i++;
   } while (result);

   if (0 == nrows) ndiffs = -1;
   LEAVE ("ndiffs=%d", ndiffs);
   return ndiffs;
}



/* ------------------------------------------------------ */
/* This routine returns a positive int if the indicated object
 * differs from that in the SQL database.  It returns negative
 * number if theres an error.
 * It does not do any traversals, it does not lock.  
 */
int
pgendCompareOneKVPdoubleOnly (PGBackend *be, store_data_t *ptr)
{
   const char *buf;
   PGresult *result;
   int i=0, nrows=0, ndiffs=0;

   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return -1;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_dbl", SQL_SELECT);
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Double (be->builder, "data", ptr->u.dbl);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);


   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, -1);

   i=0; nrows=0;
   do {
      GET_RESULTS (be->connection, result);
      IF_ONE_ROW (result, nrows, i) {

         /* Compare queried values to input values. */
             COMP_STR ("type", ptr->stype, ndiffs);
    COMP_DOUBLE ("data", ptr->u.dbl, ndiffs);

      }

      PQclear (result);
      i++;
   } while (result);

   if (0 == nrows) ndiffs = -1;
   LEAVE ("ndiffs=%d", ndiffs);
   return ndiffs;
}



/* ------------------------------------------------------ */
/* This routine returns a positive int if the indicated object
 * differs from that in the SQL database.  It returns negative
 * number if theres an error.
 * It does not do any traversals, it does not lock.  
 */
int
pgendCompareOneKVPnumericOnly (PGBackend *be, store_data_t *ptr)
{
   const char *buf;
   PGresult *result;
   int i=0, nrows=0, ndiffs=0;

   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return -1;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_numeric", SQL_SELECT);
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Int64 (be->builder, "num", ptr->u.numeric.num);
   sqlBuild_Set_Int64 (be->builder, "denom", ptr->u.numeric.denom);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);


   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, -1);

   i=0; nrows=0;
   do {
      GET_RESULTS (be->connection, result);
      IF_ONE_ROW (result, nrows, i) {

         /* Compare queried values to input values. */
             COMP_STR ("type", ptr->stype, ndiffs);
    COMP_INT64 ("num", ptr->u.numeric.num, ndiffs);
    COMP_INT64 ("denom", ptr->u.numeric.denom, ndiffs);

      }

      PQclear (result);
      i++;
   } while (result);

   if (0 == nrows) ndiffs = -1;
   LEAVE ("ndiffs=%d", ndiffs);
   return ndiffs;
}



/* ------------------------------------------------------ */
/* This routine returns a positive int if the indicated object
 * differs from that in the SQL database.  It returns negative
 * number if theres an error.
 * It does not do any traversals, it does not lock.  
 */
int
pgendCompareOneKVPstringOnly (PGBackend *be, store_data_t *ptr)
{
   const char *buf;
   PGresult *result;
   int i=0, nrows=0, ndiffs=0;

   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return -1;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_str", SQL_SELECT);
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Str (be->builder, "data", ptr->u.str);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);


   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, -1);

   i=0; nrows=0;
   do {
      GET_RESULTS (be->connection, result);
      IF_ONE_ROW (result, nrows, i) {

         /* Compare queried values to input values. */
             COMP_STR ("type", ptr->stype, ndiffs);
    COMP_STR ("data", ptr->u.str, ndiffs);

      }

      PQclear (result);
      i++;
   } while (result);

   if (0 == nrows) ndiffs = -1;
   LEAVE ("ndiffs=%d", ndiffs);
   return ndiffs;
}



/* ------------------------------------------------------ */
/* This routine returns a positive int if the indicated object
 * differs from that in the SQL database.  It returns negative
 * number if theres an error.
 * It does not do any traversals, it does not lock.  
 */
int
pgendCompareOneKVPguidOnly (PGBackend *be, store_data_t *ptr)
{
   const char *buf;
   PGresult *result;
   int i=0, nrows=0, ndiffs=0;

   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return -1;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_guid", SQL_SELECT);
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Str (be->builder, "data", ptr->u.str);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);


   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, -1);

   i=0; nrows=0;
   do {
      GET_RESULTS (be->connection, result);
      IF_ONE_ROW (result, nrows, i) {

         /* Compare queried values to input values. */
             COMP_STR ("type", ptr->stype, ndiffs);
    COMP_STR ("data", ptr->u.str, ndiffs);

      }

      PQclear (result);
      i++;
   } while (result);

   if (0 == nrows) ndiffs = -1;
   LEAVE ("ndiffs=%d", ndiffs);
   return ndiffs;
}



/* ------------------------------------------------------ */
/* This routine returns a positive int if the indicated object
 * differs from that in the SQL database.  It returns negative
 * number if theres an error.
 * It does not do any traversals, it does not lock.  
 */
int
pgendCompareOneKVPtimespecOnly (PGBackend *be, store_data_t *ptr)
{
   const char *buf;
   PGresult *result;
   int i=0, nrows=0, ndiffs=0;

   ENTER ("be=%p, store_data_t=%p", be, ptr);
   if (!be || !ptr) return -1;

   /* build the sql query */
   sqlBuild_Table (be->builder, "gncKVPvalue_timespec", SQL_SELECT);
      sqlBuild_Set_Str (be->builder, "type", ptr->stype);
   sqlBuild_Set_Date (be->builder, "data", ptr->u.ts);
   sqlBuild_Where_Int32 (be->builder, "iguid", ptr->iguid);
   sqlBuild_Where_Int32 (be->builder, "ipath", ptr->ipath);


   buf = sqlBuild_Query (be->builder);
   SEND_QUERY (be,buf, -1);

   i=0; nrows=0;
   do {
      GET_RESULTS (be->connection, result);
      IF_ONE_ROW (result, nrows, i) {

         /* Compare queried values to input values. */
             COMP_STR ("type", ptr->stype, ndiffs);
    COMP_DATE ("data", ptr->u.ts, ndiffs);

      }

      PQclear (result);
      i++;
   } while (result);

   if (0 == nrows) ndiffs = -1;
   LEAVE ("ndiffs=%d", ndiffs);
   return ndiffs;
}




/* ------------------------------------------------------ */
/* This routine inserts or updates, as appropriate
 * It does not do any traversals, it does not lock.  
 * It just updates.
 */
void 
pgendPutOneKVPint64Only (PGBackend *be, store_data_t *ptr)
{
   int ndiffs;
   ndiffs = pgendCompareOneKVPint64Only (be, ptr);

   /* update the record if there are differences ... */
   if (0<ndiffs) 
   {
      pgendStoreOneKVPint64Only (be, ptr, SQL_UPDATE);
      pgendStoreAuditKVPint64 (be, ptr, SQL_UPDATE);
   }
   /* insert the record if it doesnt exist */
   if (0>ndiffs)
   {
      pgendStoreOneKVPint64Only (be, ptr, SQL_INSERT);
      pgendStoreAuditKVPint64 (be, ptr, SQL_INSERT);
   }
}



/* ------------------------------------------------------ */
/* This routine inserts or updates, as appropriate
 * It does not do any traversals, it does not lock.  
 * It just updates.
 */
void 
pgendPutOneKVPdoubleOnly (PGBackend *be, store_data_t *ptr)
{
   int ndiffs;
   ndiffs = pgendCompareOneKVPdoubleOnly (be, ptr);

   /* update the record if there are differences ... */
   if (0<ndiffs) 
   {
      pgendStoreOneKVPdoubleOnly (be, ptr, SQL_UPDATE);
      pgendStoreAuditKVPdouble (be, ptr, SQL_UPDATE);
   }
   /* insert the record if it doesnt exist */
   if (0>ndiffs)
   {
      pgendStoreOneKVPdoubleOnly (be, ptr, SQL_INSERT);
      pgendStoreAuditKVPdouble (be, ptr, SQL_INSERT);
   }
}



/* ------------------------------------------------------ */
/* This routine inserts or updates, as appropriate
 * It does not do any traversals, it does not lock.  
 * It just updates.
 */
void 
pgendPutOneKVPnumericOnly (PGBackend *be, store_data_t *ptr)
{
   int ndiffs;
   ndiffs = pgendCompareOneKVPnumericOnly (be, ptr);

   /* update the record if there are differences ... */
   if (0<ndiffs) 
   {
      pgendStoreOneKVPnumericOnly (be, ptr, SQL_UPDATE);
      pgendStoreAuditKVPnumeric (be, ptr, SQL_UPDATE);
   }
   /* insert the record if it doesnt exist */
   if (0>ndiffs)
   {
      pgendStoreOneKVPnumericOnly (be, ptr, SQL_INSERT);
      pgendStoreAuditKVPnumeric (be, ptr, SQL_INSERT);
   }
}



/* ------------------------------------------------------ */
/* This routine inserts or updates, as appropriate
 * It does not do any traversals, it does not lock.  
 * It just updates.
 */
void 
pgendPutOneKVPstringOnly (PGBackend *be, store_data_t *ptr)
{
   int ndiffs;
   ndiffs = pgendCompareOneKVPstringOnly (be, ptr);

   /* update the record if there are differences ... */
   if (0<ndiffs) 
   {
      pgendStoreOneKVPstringOnly (be, ptr, SQL_UPDATE);
      pgendStoreAuditKVPstring (be, ptr, SQL_UPDATE);
   }
   /* insert the record if it doesnt exist */
   if (0>ndiffs)
   {
      pgendStoreOneKVPstringOnly (be, ptr, SQL_INSERT);
      pgendStoreAuditKVPstring (be, ptr, SQL_INSERT);
   }
}



/* ------------------------------------------------------ */
/* This routine inserts or updates, as appropriate
 * It does not do any traversals, it does not lock.  
 * It just updates.
 */
void 
pgendPutOneKVPguidOnly (PGBackend *be, store_data_t *ptr)
{
   int ndiffs;
   ndiffs = pgendCompareOneKVPguidOnly (be, ptr);

   /* update the record if there are differences ... */
   if (0<ndiffs) 
   {
      pgendStoreOneKVPguidOnly (be, ptr, SQL_UPDATE);
      pgendStoreAuditKVPguid (be, ptr, SQL_UPDATE);
   }
   /* insert the record if it doesnt exist */
   if (0>ndiffs)
   {
      pgendStoreOneKVPguidOnly (be, ptr, SQL_INSERT);
      pgendStoreAuditKVPguid (be, ptr, SQL_INSERT);
   }
}



/* ------------------------------------------------------ */
/* This routine inserts or updates, as appropriate
 * It does not do any traversals, it does not lock.  
 * It just updates.
 */
void 
pgendPutOneKVPtimespecOnly (PGBackend *be, store_data_t *ptr)
{
   int ndiffs;
   ndiffs = pgendCompareOneKVPtimespecOnly (be, ptr);

   /* update the record if there are differences ... */
   if (0<ndiffs) 
   {
      pgendStoreOneKVPtimespecOnly (be, ptr, SQL_UPDATE);
      pgendStoreAuditKVPtimespec (be, ptr, SQL_UPDATE);
   }
   /* insert the record if it doesnt exist */
   if (0>ndiffs)
   {
      pgendStoreOneKVPtimespecOnly (be, ptr, SQL_INSERT);
      pgendStoreAuditKVPtimespec (be, ptr, SQL_INSERT);
   }
}


