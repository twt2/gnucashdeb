Forwarded: not-needed
Origin: upstream, https://github.com/Gnucash/gnucash/commit/45bab93613e6a93b206b74ffc18f63708b07293b.patch
From 45bab93613e6a93b206b74ffc18f63708b07293b Mon Sep 17 00:00:00 2001
From: John Ralls <jralls@ceridwen.us>
Date: Tue, 7 Nov 2017 18:06:04 -0800
Subject: Bug 789928 - FTBFS with libdbi 0.9.0-5 on Debian

Commit 88b8477 on libdbi calls the error handler if one attempts to run
off the end of a result set. Since we often loop on
dbi_result_next_row() returning 0 this breaks our logic in several
places. This change simply returns from the error handler on a
DB_ERROR_BADIDX allowing the logic to work as before.

--- a/src/backend/dbi/gnc-backend-dbi.c
+++ b/src/backend/dbi/gnc-backend-dbi.c
@@ -395,10 +395,15 @@
 {
     const gchar* msg;
     GncDbiBackend *be = (GncDbiBackend*)user_data;
     GncDbiSqlConnection *dbi_conn = (GncDbiSqlConnection*)(be->sql_be.conn);
-
-    (void)dbi_conn_error( conn, &msg );
+    int err_num = dbi_conn_error( conn, &msg );
+    /* BADIDX is raised if we attempt to seek outside of a result. We
+     * handle that possibility after checking the return value of the
+     * seek. Having this raise a critical error breaks looping by
+     * testing for the return value of the seek.
+     */
+    if (err_num == DBI_ERROR_BADIDX) return;
     PERR( "DBI error: %s\n", msg );
     gnc_dbi_set_error( dbi_conn, ERR_BACKEND_MISC, 0, FALSE );
 }
 
@@ -610,16 +615,20 @@
 {
     GncDbiBackend *be = (GncDbiBackend*)user_data;
     GncDbiSqlConnection *dbi_conn = (GncDbiSqlConnection*)be->sql_be.conn;
     const gchar* msg;
-    gint err_num;
 #ifdef G_OS_WIN32
     const guint backoff_msecs = 1;
 #else
     const guint backoff_usecs = 1000;
 #endif
-
-    err_num = dbi_conn_error( conn, &msg );
+    int err_num = dbi_conn_error( conn, &msg );
+    /* BADIDX is raised if we attempt to seek outside of a result. We
+     * handle that possibility after checking the return value of the
+     * seek. Having this raise a critical error breaks looping by
+     * testing for the return value of the seek.
+     */
+    if (err_num == DBI_ERROR_BADIDX) return;
 
     /* Note: the sql connection may not have been initialized yet
      *       so let's be careful with using it
      */
@@ -1330,10 +1339,16 @@
     const guint backoff_msecs = 1;
 #else
     const guint backoff_usecs = 1000;
 #endif
+    int err_num = dbi_conn_error( conn, &msg );
+    /* BADIDX is raised if we attempt to seek outside of a result. We
+     * handle that possibility after checking the return value of the
+     * seek. Having this raise a critical error breaks looping by
+     * testing for the return value of the seek.
+     */
+    if (err_num == DBI_ERROR_BADIDX) return;
 
-    (void)dbi_conn_error( conn, &msg );
     if ( g_str_has_prefix( msg, "FATAL:  database" ) &&
             g_str_has_suffix( msg, "does not exist\n" ) )
     {
         PINFO( "DBI error: %s\n", msg );
